<!DOCTYPE html>
<html lang="ko">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>인터랙티브 스토리텔링 아키텍처 가이드</title>
		<style>
			/* 1. 입력 레이어: Lenis 부드러운 스크롤 설정 */
			html.lenis, html.lenis body {
				height: auto;
			}
			.lenis.lenis-smooth {
				scroll-behavior: auto !important;
			}
			.lenis-stopped {
				overflow: hidden;
			}
			
			/* 기본 스타일링 */
			body {
				margin: 0;
				background-color: #020617;
				color: #f8fafc;
				font-family: system-ui, -apple-system, sans-serif;
				overflow-x: hidden;
			}
			section {
				height: 100vh;
				display: flex;
				flex-direction: column;
				justify-content: center;
				align-items: center;
				padding: 2rem;
				position: relative;
				border-bottom: 1px solid rgba(255, 255, 255, 0.05);
			}

			/* 가이드 박스 스타일 */
			.guide-box {
				position: absolute;
				bottom: 10%;
				left: 50%;
				transform: translateX(-50%);
				background: rgba(30, 41, 59, 0.9);
				backdrop-filter: blur(10px);
				padding: 1rem 2rem;
				border-radius: 2rem;
				border: 1px solid rgba(56, 189, 248, 0.5);
				text-align: center;
				max-width: 80%;
				transition: all 0.5s ease;
				z-index: 10;
			}
			.guide-box strong {
				color: #38bdf8;
				display: block;
				margin-bottom: 0.25rem;
			}

			/* 차트 섹션 전용 레이아웃: sticky 적용을 위해 높이를 충분히 확보 */
			#chart-section {
				height: 150vh; /* 고정된 상태로 머무는 시간을 조절하기 위해 높이 증가 */
				display: block; /* sticky 자식 요소를 위해 block으로 변경 */
				padding: 0;
			}

			/* 차트 고정 컨테이너: 화면 중앙에 고정됨 */
			.sticky-wrapper {
				position: sticky;
				top: 0;
				height: 100vh;
				display: flex;
				justify-content: center;
				align-items: center;
				flex-direction: column;
			}

			/* 선택하신 코드: 차트 박스 스타일 */
			.chart-container {
				width: 90%;
				max-width: 850px;
				height: 450px;
				background: rgba(255, 255, 255, 0.02);
				border: 1px solid rgba(255, 255, 255, 0.1);
				border-radius: 1.5rem;
				padding: 2.5rem;
				display: flex;
				flex-direction: column;
				box-sizing: border-box;
				position: relative;
			}

			#d3-chart {
				flex: 1;
				width: 100%;
				min-height: 300px;
			}
			.bar {
				fill: #38bdf8;
				cursor: pointer;
			}
			.bar:hover {
				fill: #7dd3fc;
			}
			.axis-text text {
				fill: #94a3b8;
				font-size: 13px;
			}
			
			h1 {
				font-size: clamp(2.5rem, 6vw, 5rem);
				margin: 0;
				background: linear-gradient(to bottom right, #f8fafc, #94a3b8);
				-webkit-background-clip: text;
				-webkit-text-fill-color: transparent;
				text-align: center;
			}
			.highlight { color: #38bdf8; }
			
			@keyframes bounce {
				0%, 20%, 50%, 80%, 100% {transform: translateY(0) translateX(-50%);}
				40% {transform: translateY(-10px) translateX(-50%);}
				60% {transform: translateY(-5px) translateX(-50%);}
			}

			.scroll-indicator {
				position: absolute; 
				bottom: 2rem; 
				left: 50%; 
				animation: bounce 2s infinite;
				font-size: 2rem;
			}
		</style>
	</head>
	<body>
		<main>
			<!-- 섹션 1: 입력(Input) 단계 설명 -->
			<section id="intro">
				<h1>Phase 1: <span class="highlight">Input</span></h1>
				<p>지금 느끼시는 부드러운 움직임은 <strong>Lenis</strong>가 담당합니다.</p>
				<div class="guide-box">
					<strong>[입력 처리 중]</strong>
					마우스 휠의 거친 입력을 Lenis가 가로채 부드러운 가속도로 변환하고 있습니다.
				</div>
				<div class="scroll-indicator">↓</div>
			</section>

			<!-- 섹션 2: 처리(Processing) & 출력(Output) 단계 -->
			<section id="chart-section">
				<div class="sticky-wrapper">
					<div class="chart-container">
						<h2 style="margin: 0 0 1.5rem 0; font-size: 1.8rem;">Interactive Data Flow</h2>
						<div id="d3-chart"></div>
					</div>
					<div class="guide-box" id="step-guide">
						<strong>[처리 및 출력 대기]</strong>
						ScrollTrigger가 섹션의 위치를 감시하고 있습니다.
					</div>
				</div>
			</section>

			<!-- 섹션 3: 결과 요약 -->
			<section id="outro">
				<h1>Mastered.</h1>
				<p>이제 당신은 인터랙티브 웹의 기본 원리를 이해했습니다.</p>
				<div class="guide-box">
					<strong>[최종 출력 완료]</strong>
					모든 데이터 시각화와 애니메이션이 성공적으로 렌더링되었습니다.
				</div>
			</section>
		</main>

		<script type="module">
			import Lenis from 'https://cdn.jsdelivr.net/npm/lenis@1.1.18/+esm';
			import { gsap } from 'https://cdn.jsdelivr.net/npm/gsap@3.12.5/+esm';
			import { ScrollTrigger } from 'https://cdn.jsdelivr.net/npm/gsap@3.12.5/ScrollTrigger/+esm';
			import * as d3 from 'https://cdn.jsdelivr.net/npm/d3@7/+esm';

			gsap.registerPlugin(ScrollTrigger);

			let lenis; 
			let ctx;   

			function init() {
				lenis = new Lenis({
					duration: 0.95,
					easing: (t) => Math.min(1, 1.001 - Math.pow(2, -20 * t)),
				});

				function raf(time) {
					lenis.raf(time);
					requestAnimationFrame(raf);
				}
				requestAnimationFrame(raf);

				lenis.on('scroll', ScrollTrigger.update);

				renderChart();
			}

			function renderChart() {
				const container = document.getElementById('d3-chart');
				
				if (!container) return;
				
				container.innerHTML = '';
				if (ctx) ctx.revert();

				const data = [
					{ label: 'Lenis', value: 85 },
					{ label: 'GSAP', value: 95 },
					{ label: 'D3.js', value: 75 },
					{ label: 'Astro', value: 90 },
					{ label: 'Design', value: 80 }
				];

				const width = container && container.offsetWidth > 0 ? container.offsetWidth : 800;
				const height = container && container.offsetHeight > 0 ? container.offsetHeight : 300;
				const margin = { top: 20, right: 30, bottom: 40, left: 40 };

				const svg = d3.select(container)
					.append('svg')
					.attr('width', '100%')
					.attr('height', '100%')
					.attr('viewBox', `0 0 ${width} ${height}`)
					.style('overflow', 'visible');

				const x = d3.scaleBand()
					.domain(data.map(d => d.label))
					.range([margin.left, width - margin.right])
					.padding(0.4);

				const y = d3.scaleLinear()
					.domain([0, 100])
					.range([height - margin.bottom, margin.top]);

				svg.append('g')
					.attr('transform', `translate(0,${height - margin.bottom})`)
					.call(d3.axisBottom(x).tickSize(0).tickPadding(12))
					.attr('class', 'axis-text')
					.select('.domain').remove();

				const bars = svg.selectAll('.bar')
					.data(data)
					.enter()
					.append('rect')
					.attr('class', 'bar')
					.attr('x', d => x(d.label))
					.attr('y', height - margin.bottom)
					.attr('width', x.bandwidth())
					.attr('height', 0)
					.attr('rx', 6);

				const guide = document.getElementById('step-guide');
				
				ctx = gsap.context(() => {
					gsap.to(".bar", {
						height: (i) => (height - margin.bottom) - y(data[i].value),
						y: (i) => y(data[i].value),
						duration: 1.2,
						stagger: 0.1,
						ease: "back.out(1.7)",
						scrollTrigger: {
							trigger: ".sticky-wrapper", // 실제 고정되는 요소를 기준으로 변경
							start: "top top",           // 화면 상단에 닿으면 시작
							toggleActions: "play none none reverse",
							onEnter: () => {
								if (guide) {
									guide.innerHTML = "<strong>[처리 및 출력 시작]</strong>GSAP가 타이밍을 감지하여 D3 막대를 애니메이션합니다.";
									guide.style.borderColor = "#38bdf8";
								}
							},
							onLeaveBack: () => {
								if (guide) {
									guide.innerHTML = "<strong>[처리 대기 중]</strong>스크롤이 올라갔습니다. 다시 내리면 실행됩니다.";
									guide.style.borderColor = "rgba(56, 189, 248, 0.3)";
								}
							}
						}
					});
				});
			}

			if (document.readyState === 'complete') {
				init();
			} else {
				window.addEventListener('load', init);
			}

			let resizeTimer;
			window.addEventListener('resize', () => {
				clearTimeout(resizeTimer);
				resizeTimer = setTimeout(renderChart, 250);
			});
		</script>
	</body>
</html>